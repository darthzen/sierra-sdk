<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
	<head>
		<link rel="stylesheet" href="stylesheet.css" type="text/css"/>
	</head>
<body>
<div id="container">
<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div>
<div id="main">
	<div id="navigation">
		<h2>Modules</h2>
			<ul><li>
				<a href="index.html">index</a>
			</li></ul>
		<ul>
					<li><a href="airvantage.html">airvantage</a></li>
					<li>airvantage.asset</li>
					<li><a href="airvantage.table.html">airvantage.table</a></li>
					<li><a href="checks.html">checks</a></li>
					<li><a href="coroutine.html">coroutine</a></li>
					<li><a href="debug.html">debug</a></li>
					<li><a href="devicetree.html">devicetree</a></li>
					<li><a href="global.html">global</a></li>
					<li><a href="io.html">io</a></li>
					<li><a href="lfs.html">lfs</a></li>
					<li><a href="log.html">log</a></li>
					<li><a href="lua.html">lua</a></li>
					<li><a href="math.html">math</a></li>
					<li><a href="modbus.html">modbus</a></li>
					<li><a href="modbustcp.html">modbustcp</a></li>
					<li><a href="niltoken.html">niltoken</a></li>
					<li><a href="os.html">os</a></li>
					<li><a href="pack.html">pack</a></li>
					<li><a href="package.html">package</a></li>
					<li><a href="persist.html">persist</a></li>
					<li><a href="sched.html">sched</a></li>
					<li><a href="serial.html">serial</a></li>
					<li><a href="sms.html">sms</a></li>
					<li><a href="socket.html">socket</a></li>
					<li><a href="string.html">string</a></li>
					<li><a href="system.html">system</a></li>
					<li><a href="table.html">table</a></li>
					<li><a href="timer.html">timer</a></li>
					<li><a href="utils.loader.html">utils.loader</a></li>
					<li><a href="utils.ltn12.source.html">utils.ltn12.source</a></li>
					<li><a href="utils.path.html">utils.path</a></li>
					<li><a href="utils.table.html">utils.table</a></li>
		</ul>
	</div>
	<div id="content">
   <h1>Module <code>airvantage.asset</code></h1>
   
<p>this module relay the data to the ReadyAgent; the ReadyAgent then manages
the data as described.</p>

   

<p>For information regarding supported policies, see the <a href="airvantage.html##(airvantage)">airvantage#airvantage</a> module
documentation.</p>

<p>Two methods are supported for sending data to the AirVantage servers:</p>

<ol>
    <li><code>pushData</code>:  this is a simple API for managing how to send data,
    this is the recommended method for most use cases.</li>
    <li>Tables (via <code>newTable</code>): this allows for more advanced control of the
    transfer of data; it is an experimental API.</li>
</ol>

<p>Moreover, methods <code>setUpdateHook</code> and <code>sendUpdateResult</code> are provided to let application handle
software update requests from the AirVantage servers in a custom way.</p>

<p><strong>NOTE:</strong> The AirVantage APIs are currently in BETA and are subject to
change in the subsequent release.</p>


			<h2><a id="#(asset)">Type <code>asset</code></a></h2>
				<table class="function_list">
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(asset).close">asset:close()</a></td>
		<td class="summary">
<p>Closes an <a href="##(asset)">#asset</a> instance.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(asset).pushData">asset:pushData(path, data, sendpolicy)</a></td>
		<td class="summary">
<p>Pushes some unstructured data to the agent.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(asset).sendUpdateResult">asset:sendUpdateResult(componentName, updateResult)</a></td>
		<td class="summary">
<p>Sends the result of the software update request previously received by an asset.</p>

</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(asset).setUpdateHook">asset:setUpdateHook(hook)</a></td>
		<td class="summary">
<p>Changes the hook function to be called when the asset receives a software
update request from the portal.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(asset).start">asset:start()</a></td>
		<td class="summary">
<p>Starts a newly created <a href="##(asset)">#asset</a>.</p>
</td>
		</tr>
		<tr>
		<td class="name" nowrap="nowrap"><a href="##(asset).tree">asset.tree</a></td>
		<td class="summary">
<p>airvantage.asset data tree</p>

<p>An <a href="##(asset)">#asset</a> contains a data tree, in its field <code>tree</code>.</p>
</td>
		</tr>
	</table>

	<h2><a id="#(airvantage.asset)" >Type <code>airvantage.asset</code></a></h2>
	
			<h2><a id="#(asset)" >Type <code>asset</code></a></h2>
				<h3>Field(s)</h3>
		<dl class="function">
<dt>
<a id="#(asset).close" >
<strong>asset:close()</strong>
</a>
</dt>
<dd>
	
<p>Closes an <a href="##(asset)">#asset</a> instance.</p>

	

<p>Once this destructor method has been called, no more message can be sent
nor received by the instance, and the resources it reserved can be reclaimed,
either immediately or through the garbage collection cycle.</p>


		<h3>Return value</h3>
				

<p><code>"ok"</code> on success.</p>



</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(asset).pushData" >
<strong>asset:pushData(path, data, sendpolicy)</strong>
</a>
</dt>
<dd>
	
<p>Pushes some unstructured data to the agent.</p>

	

<p>Those data are not necessarily moved forward from the agent to the server
immediately: agent-to-server data transfers are managed through policies,
as described in the <em>AirVantage technical article</em>.</p>

<p>This API is optimized for ease of use: it will internally try to reformat
data in the most sensible, server-compatible way. Applications requiring a
tight control over how data are structured, buffered, consolidated and
reported should consider the more advanced <a href="##(asset).newTable">asset.newTable</a> API.</p>

<p>Data send through <code>pushData</code> can be a flat set of key/values in a record,
or can contain nested sub-records. It can also be a simple value out of a
record, if the path is not empty: in this case, the last path segment will be
used as a datastore key.</p>


		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em> path </em></code>: 
the datastore path under which data will be stored relative to
  the asset node (optional).</p>

				</li>
				<li>
				
<p><code><em> data </em></code>: 
a table of key/value pairs, or a simple non-table serializable
  value.</p>

				</li>
				<li>
				
<p><code><em> sendpolicy </em></code>: 
name of the policy controlling when the data must be sent
  to the server, if omitted then the default policy is used.</p>

				</li>
		</ul>
		<h3>Return values</h3>
			<ol>
				<li>
				

<p><code>"ok"</code> on success.</p>

				</li>
				<li>
				

<p><code>nil</code> followed by an error message otherwise.</p>



				</li>
			</ol>
</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(asset).sendUpdateResult" >
<strong>asset:sendUpdateResult(componentName, updateResult)</strong>
</a>
</dt>
<dd>
	
<p>Sends the result of the software update request previously received by an asset.</p>


		<h3>Parameters</h3>
		<ul>
				<li>
				
<p><code><em> componentName </em></code>: 
a string, this must be the same value as the one
that was given as argument to the update hook (the hook registered with #setUpdateHook). <br>
As only one software update is possible for the same component at the same time,
the couple asset+componentName fully identifies the software update request.</p>

				</li>
				<li>
				
<p><code><em> updateResult </em></code>: 
a number, the result of the update, 200 for success,
any other value means error. <br>
Values from 480 to 499 are reserved for applicative error codes, so it is highly recommended
to use one (or more) of those to signify an error coming from an asset update.</p>


				</li>
		</ul>
		<h3>Return values</h3>
			<ol>
				<li>
				

<p> "ok" on success</p>

				</li>
				<li>
				

<p><code>nil</code> + error message otherwise.</p>


				</li>
			</ol>
</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(asset).setUpdateHook" >
<strong>asset:setUpdateHook(hook)</strong>
</a>
</dt>
<dd>
	
<p>Changes the hook function to be called when the asset receives a software
update request from the portal.</p>

	

<p><strong>Notes:</strong></p>

<ul>
    <li>There can be only one pending <code>SoftwareUpdate</code> request at a time.</li>
    <li>Only one hook can be registered for the whole asset</li>
    <li>If no user update hook is set, the error code 472 (meaning "not supported /
    not implemented") will be reported to the server.</li>
    <li>Any error coming from this update request means that the whole update
    process will be considered as failed.</li>
    <li>When an update request tries to install a version that is already
    installed, the application should return success value.
    Indeed, in some cases the asset instance won't receive and report the hook's
    result (e.g. because of a poorly timed reboot). As a result, the update
    request will be sent again, and the hook should report a success immediately.</li>
</ul>


		<h3>Parameter</h3>
		<ul>
				<li>
				
<p><code><em> hook </em></code>: 
the new function to handle software update request.
  hook signature: <br> <code>hook(componentname, version, path, parameters)</code></p>

<ul>
    <li><code>componentname</code> (string) is the identifier of the component to update,
    the name is defined in update manifest file, here it is provided
    without the assetid at the beginning.</li>
    <li><code>version</code> (string) is the version of the component to install
    version can be empty string (but not nil!) to specify de-installation
    request, non empty string for regular update/install of software
    component.</li>
    <li><code>path</code> (string) can be empty when version is empty too, otherwise path
    will be a non empty string defining the absolute path of the file/folder
    to use to update the application.</li>
    <li><code>parameters</code> (table), can be nil, when set it contains the content
    of parameters fields from update package, those parameters provide a way to give application specific
    update parameters.
    <br><br></li>
    <li><code>return value</code>: an integer, 200 for success, any other value means error.
    Values from 480 to 499 are reserved for applicative error codes,
    so it is highly recommended to use one (or more) of those to signify
    an error coming from this update hook.
    Non-integer return values will be rejected and be replaced by
    default value 471.</li>
</ul>

				</li>
		</ul>
		<h3>Return values</h3>
			<ol>
				<li>
				

<p><code>"ok"</code> on success.</p>

				</li>
				<li>
				

<p><code>nil</code> followed by an error message otherwise.</p>



				</li>
			</ol>
</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(asset).start" >
<strong>asset:start()</strong>
</a>
</dt>
<dd>
	
<p>Starts a newly created <a href="##(asset)">#asset</a>.</p>

	

<p>Allows the <a href="##(asset)">#asset</a> instance to send and receive messages to/from the servers.</p>

<p>An <a href="##(asset)">#asset</a> instance which has been started, then experiences an unrecoverable
error or an explicit call to <a href="asset.html">asset</a> emits a <code>"closed"</code> event
(cf. <a href="sched.html##(signal)">sched#signal</a>).</p>


		<h3>Return values</h3>
			<ol>
				<li>
				

<p><code>"ok"</code> on success.</p>

				</li>
				<li>
				

<p><code>nil</code> followed by an error message otherwise.</p>



				</li>
			</ol>
</dd>
</dl>
		<dl class="function">
<dt>
<a id="#(asset).tree" >
<strong>asset.tree</strong>
</a>
</dt>
<dd>
	
<p>airvantage.asset data tree</p>

<p>An <a href="##(asset)">#asset</a> contains a data tree, in its field <code>tree</code>.</p>

	

<p>When the server sends data to an asset, the way it reacts is determined by
the tree's content:</p>

<ul>
    <li>if there's a function in the tree under a path which is the prefix of the
    data's path, this function is called as a handler;</li>
    <li>if there's no specific handler, but a handler is found in a <code>__default</code>
    field in a prefix of the data's path, this generic handler is used. If
    several generic handlers are found, the one corresponding to the longest
    prefix is chosen.</li>
    <li>if no handler is found at all, the value sent by the server is written
    in the tree, under its path.</li>
</ul>

<p>For instance, if the server sends <code>myAsset.foo.bar=123</code>:</p>

<ul>
    <li>if there's a function in one of <code>myAsset.tree.foo.bar</code>, <code>myAsset.tree.foo</code>
    or <code>myAsset.tree</code>,  this function is called;</li>
    <li>if there's no such function, but at least one default handler is found
    in either <code>myAsset.tree.foo.__default</code> or <code>myAsset.tree.__default</code>, the one
    with the longest path is called;</li>
    <li>if no handler is found, the value <code>123</code> is written in <code>myAsset.tree.foo.bar</code>.</li>
</ul>

<p>Handlers are functions which receive as parameters:</p>

<ul>
    <li><code>self</code> the asset instance;</li>
    <li><code>data</code> the map of keys/values sent by the server; keys are paths relative
    to the node where the handler is attached;</li>
    <li><code>path</code> the path string where the handler is attached; concatenated in front
    of each key, it allows to retrieve absolute paths.</li>
</ul>

<p>Handlers must return:</p>

<ul>
    <li>the status code <code>0</code> to indicate success;</li>
    <li>a non-zero numeric status code to indicate failure, optionally followed
    by an error message.</li>
</ul>

<p>The data tree comes with a pre-installed handler function on the path
<code>myAsset.tree.commands.ReadNode</code>. It handles standard requests by the server
when it wants to read the content of an arbitrary path in the asset's tree.</p>

<p>Notice that handler functions should be installed in the data tree before
the asset is started with <a href="##(asset).start">asset.start</a>: otherwise, any server message
received between the start and the handler attachment will be lost.</p>


</dd>
</dl>

</div>

</div>
</body>
</html>
